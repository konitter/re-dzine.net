<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>REFLECTDESIGN</title>
  <id>http://re-dzine.net/</id>
  <link href="http://re-dzine.net/"/>
  <link href="http://re-dzine.net/feed.xml" rel="self"/>
  <updated>2014-12-18T06:28:00Z</updated>
  <author>
    <name>konitter</name>
  </author>
  <entry>
    <title>Sublime Text 3 Settings</title>
    <link rel="alternate" href="http://re-dzine.net/2014/12/st3-settings/"/>
    <id>http://re-dzine.net/2014/12/st3-settings/</id>
    <published>2014-12-18T06:28:00Z</published>
    <updated>2014-12-18T16:10:29+09:00</updated>
    <author>
      <name>konitter</name>
    </author>
    <content type="html">この記事は [Sublime Text Advent Calendar 2014](http://www.adventar.org/calendars/407) 18日目の記事です。

1ヵ月くらい前にSublime Text 2から3に乗り換えました。それにあたって設定やプラグイン周りを色々と見直したので、そんなことを簡単にまとめたいと思います。

## プラグインの移行

2から3に移行する場合に一番気になるのが、今まで使ってたプラグインが3でも使えるかどうか。じゃあプラグインのGitHubとかを見て、3に対応してるかどうか1つずつ確認するのは非常にめんどいわけです。

でも世の中には便利なものを作ってくれる人がいまして。「[Can I Switch To Sublime Text 3?](http://www.caniswitchtosublimetext3.com/)」というそのまんまなツールで、インストールしているパッケージが書かれたファイル``Package Control.sublime-settings``の中身を画面内のテキストエリアにコピペして「Can I Switch?」のボタンを押すだけで、プラグインが3に対応してるかを判定してくれます。

![Can I Switch To Sublime Text 3?の判定結果](/img/2014/12/st3_01.png)

全部のプラグインが3に対応していれば、「YES!」と出ます。もし対応していないプラグインがあれば明示してくれるので、それが絶対に必要なものかどうかを検討してみると良いと思います。だいたいはほとんど使ってないものだったり、3に対応した代わりのプラグインが他にあったりします。

## Package Control

3でもPackage Controlは必要なのでまず最初にインストールします。インストールの仕方は2のときと同じですが、&lt;code&gt;ctrl+`&lt;/code&gt;
</content>
  </entry>
  <entry>
    <title>Sublime Text 3 Settings</title>
    <link rel="alternate" href="http://re-dzine.net/2014/12/st3-settings/"/>
    <id>http://re-dzine.net/2014/12/st3-settings/</id>
    <published>2014-12-18T06:28:00Z</published>
    <updated>2014-12-18T16:09:07+09:00</updated>
    <author>
      <name>konitter</name>
    </author>
    <content type="html">この記事は [Sublime Text Advent Calendar 2014](http://www.adventar.org/calendars/407) 18日目の記事です。

1ヵ月くらい前にSublime Text 2から3に乗り換えました。それにあたって設定やプラグイン周りを色々と見直したので、そんなことを簡単にまとめたいと思います。

## プラグインの移行

2から3に移行する場合に一番気になるのが、今まで使ってたプラグインが3でも使えるかどうか。じゃあプラグインのGitHubとかを見て、3に対応してるかどうか1つずつ確認するのは非常にめんどいわけです。

でも世の中には便利なものを作ってくれる人がいまして。「[Can I Switch To Sublime Text 3?](http://www.caniswitchtosublimetext3.com/)」というそのまんまなツールで、インストールしているパッケージが書かれたファイル``Package Control.sublime-settings``の中身を画面内のテキストエリアにコピペして「Can I Switch?」のボタンを押すだけで、プラグインが3に対応してるかを判定してくれます。

![Can I Switch To Sublime Text 3?の判定結果](/img/2014/12/st3_01.png)

全部のプラグインが3に対応していれば、「YES!」と出ます。もし対応していないプラグインがあれば明示してくれるので、それが絶対に必要なものかどうかを検討してみると良いと思います。だいたいはほとんど使ってないものだったり、3に対応した代わりのプラグインが他にあったりします。

## Package Control

3でもPackage Controlは必要なのでまず最初にインストールします。インストールの仕方は2のときと同じですが、``ctrl+```
</content>
  </entry>
  <entry>
    <title>Sublime Text 3 Settings</title>
    <link rel="alternate" href="http://re-dzine.net/2014/12/st3-settings/"/>
    <id>http://re-dzine.net/2014/12/st3-settings/</id>
    <published>2014-12-18T06:28:00Z</published>
    <updated>2014-12-18T18:05:00+09:00</updated>
    <author>
      <name>konitter</name>
    </author>
    <content type="html">&lt;p&gt;この記事は &lt;a href="http://www.adventar.org/calendars/407"&gt;Sublime Text Advent Calendar 2014&lt;/a&gt; 18日目の記事です。&lt;/p&gt;

&lt;p&gt;1ヵ月くらい前にSublime Text 2から3に乗り換えました。それにあたって設定やパッケージ周りを色々と見直したので、そんなことを簡単にまとめたいと思います。&lt;/p&gt;

&lt;h2&gt;Preparation&lt;/h2&gt;

&lt;p&gt;2から3に移行する場合に一番気になるのが、今まで使ってたパッケージが3でも使えるかどうか。じゃあパッケージのGitHubとかを見て、3に対応してるかどうか1つずつ確認するのは非常にめんどいわけです。&lt;/p&gt;

&lt;p&gt;でも世の中には便利なものを作ってくれる人がいまして。「&lt;a href="http://www.caniswitchtosublimetext3.com/"&gt;Can I Switch To Sublime Text 3?&lt;/a&gt;」というそのまんまなツールで、&lt;code&gt;Package Control.sublime-settings&lt;/code&gt;の中身を画面にコピペして「Can I Switch?」のボタンを押すだけで、パッケージが3に対応してるかを判定してくれます。&lt;/p&gt;

&lt;p&gt;&lt;img alt="Can I Switch To Sublime Text 3?の判定結果" src="/img/2014/12/st3_01.png" /&gt;&lt;/p&gt;

&lt;p&gt;全部のパッケージが3に対応していれば、「YES!」と出ます。もし対応していないパッケージがあれば明示してくれるので、それが絶対に必要なものかどうかを検討してみると良いと思います。だいたいはほとんど使ってないものだったり、3に対応した代わりのパッケージが他にあったりします。&lt;/p&gt;

&lt;h2&gt;Package Control&lt;/h2&gt;

&lt;p&gt;3でもPackage Controlは必須なのでまず最初にインストールします。インストールの仕方は2のときと同じですが、コンソールに貼り付けるコードが2とは違います。詳しくは&lt;a href="https://sublime.wbond.net/installation#Simple"&gt;Installation - Package Control&lt;/a&gt;を見てもらえればわかるかと。&lt;/p&gt;

&lt;h2&gt;Theme &amp;amp; Color Scheme&lt;/h2&gt;

&lt;p&gt;Package Controlがインストールできたら、テーマを変えたくなるのがSublimer（Sublime Textユーザーのこと）（勝手に決めた）というものです。せっかく3に移行するなら、2とは別のテーマにしてみるのもいいんじゃないでしょうか？今使っているのは、&lt;a href="https://github.com/thinkpixellab/flatland"&gt;Flatland&lt;/a&gt;のDarkなテーマに&lt;a href="https://github.com/jonschlinkert/sublime-monokai-extended"&gt;Monokai Extended&lt;/a&gt;なカラースキームです。&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sublime Text 3でHTMLを表示した画面" src="/img/2014/12/st3_02.png" /&gt;&lt;/p&gt;

&lt;p&gt;他にどんなテーマがあるかは、&lt;a href="https://sublime.wbond.net/browse/labels/theme"&gt;Package Controlのサイトのthemeラベルのページ&lt;/a&gt;や、Scotchの&lt;a href="http://scotch.io/bar-talk/the-best-sublime-text-3-themes-of-2014"&gt;The Best Sublime Text 3 Themes of 2014&lt;/a&gt;とかで。&lt;/p&gt;

&lt;h2&gt;Personalisation&lt;/h2&gt;

&lt;p&gt;現状、カスタマイズした設定やキーマップ、各種パッケージの設定周りは、&lt;a href="https://github.com/konitter/sublime-settings"&gt;GitHubにアップ&lt;/a&gt;しています（みんなも設定ファイルを共有しよう！）。その中でも個人的に地味に便利だと思っているキーマップをご紹介します。&lt;/p&gt;

&lt;h3&gt;Only Package Control of command&lt;/h3&gt;

&lt;p&gt;なんだかんだでPackage Control絡みのコマンドは使う機会が多いと思います。ぼくは以下のキーマップを設定して&lt;code&gt;Super+Alt+p&lt;/code&gt;でPackage Controlのコマンドだけを呼び出せるようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &amp;quot;keys&amp;quot;: [&amp;quot;super+alt+p&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;show_overlay&amp;quot;, &amp;quot;args&amp;quot;: {&amp;quot;overlay&amp;quot;: &amp;quot;command_palette&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Package Control: &amp;quot;} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt="Sublime Text 3でHTMLを表示した画面" src="/img/2014/12/st3_03.png" /&gt;&lt;/p&gt;

&lt;p&gt;↑こんな風に。&lt;/p&gt;

&lt;h3&gt;Re-indent the whole file with a single key&lt;/h3&gt;

&lt;p&gt;ファイルや選択範囲のインデントを一発で整形できるコマンド「Re-indent」は、デフォルトではキーマップが設定されていません。コマンドパレットから都度呼び出してもいいんですが、以下の設定で&lt;code&gt;F10&lt;/code&gt;で実行できるようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &amp;quot;keys&amp;quot;: [&amp;quot;f10&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;reindent&amp;quot;, &amp;quot;args&amp;quot;: {&amp;quot;single_line&amp;quot;: false}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Package Syncing&lt;/h2&gt;

&lt;p&gt;ぼくは仕事ではWindows/家ではMacなのですが、複数の環境でSublime Textを同じセッティングで使いたいときはあると思います。そんなときパッケージのフォルダごとごっそりコピペしてしまいがちですが、それは非常に危険です。&lt;a href="https://sublime.wbond.net/docs/syncing"&gt;Package ControlのSyncingというページ&lt;/a&gt;には以下のように書かれています。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To properly sync your installed packages across different machines, you actually do not want to sync the whole Packages/ and Installed Packages/ folders. The reason for this is that some packages have different versions for different operating systems. By syncing the actual package contents across operating systems, you will possibly run into broken packages.&lt;/p&gt;

&lt;p&gt;The proper solution is to install Package Control on all machines and then to sync only the Packages/User/ folder. This folder contains the Package Control.sublime-settings file, which includes a list of all installed packages. If this file is copied to another machine, the next time Sublime Text is started, Package Control will install the correct version of any missing packages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;超要約すると、「パッケージによってはOSごとに異なるバージョンが存在しているものがあってうまく実行されない場合があるので&lt;code&gt;Packages/&lt;/code&gt;や&lt;code&gt;Installed Packages/&lt;/code&gt;ごと同期するのは辞めようぜ。一番いいのは、すべてのマシンにPackage Controlをインストールして&lt;code&gt;Packages/User/&lt;/code&gt;のみを同期することなんだ。そのフォルダ内の&lt;code&gt;Package Control.sublime-settings&lt;/code&gt;に書かれたパッケージでインストールされていないものがあれば、Sublime Textを起動したときに自動的にインストールされるんだぜ。」です。&lt;/p&gt;

&lt;p&gt;この機能を使えば、新しいPCなどにSublime Textを改めてセッティングするときにはとっても便利なわけです。&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;長くなってきたのでこの辺で。続く18日目は&lt;a href="https://twitter.com/kasshy"&gt;@kasshyさん&lt;/a&gt;です。よろしくお願いしまーす！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>【告知】『Web制作者のためのCSS設計の教科書』出版記念イベントを11/8に大阪で開催します</title>
    <link rel="alternate" href="http://re-dzine.net/2014/10/textbook-of-css-design/"/>
    <id>http://re-dzine.net/2014/10/textbook-of-css-design/</id>
    <published>2014-10-17T05:29:00Z</published>
    <updated>2014-10-17T16:29:28+09:00</updated>
    <author>
      <name>konitter</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://peatix.com/event/55901/"&gt;&lt;img src="/img/2014/10/peatix.png" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;11/8(土)に株式会社サイバーエージェントの谷拓樹さん（&lt;a href="http://twitter.com/hiloki"&gt;@hiloki&lt;/a&gt;）が執筆された『Web制作者のためのCSS設計の教科書』という書籍の出版記念イベントを開催します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://peatix.com/event/55901/"&gt;『Web制作者のためのCSS設計の教科書』出版記念イベント | Peatix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;元々は少し前に東京で行われたCSS設計に関するイベントに対して、自分がFacebook上で「CSSオジサンをやったら面白いんじゃないか（&lt;a href="https://atnd.org/events/55138"&gt;JSオジサン&lt;/a&gt;のオマージュ的なノリで）」みたいなことを言ったら、執筆者の谷さんや今回ゲストで登壇いただく斉藤さん（&lt;a href="https://twitter.com/cssradar"&gt;@cssradar&lt;/a&gt;）さんに捕捉され、気付けばあれよあれよという間にこんな大きなイベントを主催することとなりました。&lt;/p&gt;

&lt;p&gt;で、セッション内容など詳しくは告知ページを見てもらえたらと思いますが、例え書籍を持っていなくても参加可能で、CSSの設計に少しでも興味があるような人であれば十分に楽しめる・学べる構成になっています。&lt;/p&gt;

&lt;p&gt;今回谷さんに加えて、谷さんが書籍執筆の際にレビューの協力をされたという株式会社リッチメディアの斉藤祐也さん、そして本書の中でも紹介されているCSS解析ツール「&lt;a href="https://github.com/t32k/stylestats"&gt;StyleStats&lt;/a&gt;」の開発者でもある石本光司さん（&lt;a href="http://twitter.com/t32k/"&gt;@t32k&lt;/a&gt;）さんにも登壇いただきます。&lt;/p&gt;

&lt;p&gt;谷さんからはこれからのWeb制作に必須となってきているメンテナブル（修正しやすい）なCSS設計のテクニックや考え方を、斉藤さんからはCSSコードレビューのアプローチと手法、石本さんからはCSS解析ツールやエンジニアのキャリアパスについてのお話まで、盛りだくさんな内容です。&lt;/p&gt;

&lt;p&gt;本編終了後にはビアバッシュ形式のアフターパーティーをご用意していますので、CSSに限らずフロントエンドの技術的なことやキャリア設計などなど直接講師陣達とお話することができます。はっきり言って、こんな豪華な講師陣が大阪でそろうことは早々ないと思います。ぜひ、この機会にご参加ください！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Emmetの次期バージョンv1.1(Beta)の新機能がスゴい</title>
    <link rel="alternate" href="http://re-dzine.net/2014/02/emmet-beta-v1-1/"/>
    <id>http://re-dzine.net/2014/02/emmet-beta-v1-1/</id>
    <published>2014-02-13T02:00:00Z</published>
    <updated>2014-02-13T11:09:15+09:00</updated>
    <author>
      <name>konitter</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://emmet.io/"&gt;Emmet&lt;/a&gt;といえば、HTMLやCSSが爆速で書けるようになるWeb制作者なら誰もが知っているであろうアレですが、現在次期バージョンとしてv1.1の開発が進められています。そのことは、昨年の12月23日に&lt;a href="http://emmet.io/blog/beta-v1-1/"&gt;Emmet公式ブログで発表&lt;/a&gt;されたものの、あまり話題になっていないようなのでここで簡単にご紹介します。&lt;/p&gt;

&lt;h2&gt;インストール方法&lt;/h2&gt;

&lt;p&gt;v1.1(Beta)は現状&lt;a href="http://www.sublimetext.com/"&gt;Sublime Text&lt;/a&gt;でのみ試すことができます。なお、現時点ではまだ正式なリリース版ではありませんので、ご利用はあくまでも自己責任でお願いします。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;すでにEmmetを入れているなら別の場所にバックアップを取ったうえでPackage ControlからEmmetを削除。&lt;/li&gt;
&lt;li&gt;一旦Sublime Textを終了しておく。&lt;/li&gt;
&lt;li&gt;ターミナルからSublime Textの&lt;code&gt;Packages&lt;/code&gt;フォルダに移動して&lt;a href="https://github.com/sergeche/emmet-sublime/"&gt;プラグインのレポジトリ&lt;/a&gt;を&lt;code&gt;git clone&lt;/code&gt;し、v1.1のブランチに&lt;code&gt;git checkout v1.1&lt;/code&gt;で切り替える。そういうのが難しい人は&lt;a href="https://github.com/sergeche/emmet-sublime/archive/v1.1.zip"&gt;ここからダウンロード&lt;/a&gt;して解凍したものを置く。&lt;/li&gt;
&lt;li&gt;Sublime Textを起動。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;v1.1の新機能（11個）&lt;/h2&gt;

&lt;h3&gt;1. Can I Useデータベースのサポート&lt;/h3&gt;

&lt;p&gt;ベンダープレフィックスが必要なCSSのプロパティおよびその値の展開には、CSSやHTML5などの各ブラウザ対応状況が確認できるWebサービス「&lt;a href="http://caniuse.com/"&gt;Can I Use&lt;/a&gt;」のデータベースを用いて行われます。&lt;br&gt;
デフォルトでは全ブラウザの2つ前までを範囲としますが、&lt;code&gt;caniuse.era&lt;/code&gt;と&lt;code&gt;caniuse.vendors&lt;/code&gt;の設定で微調整することができるようです。くわしくはこの&lt;a href="https://github.com/emmetio/emmet/blob/umd/lib/assets/caniuse.js#L19"&gt;モジュールヘッダー&lt;/a&gt;を参照。&lt;/p&gt;

&lt;h3&gt;2. LESSとSCSSのフルサポート&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://docs.emmet.io/actions/toggle-comment/"&gt;Toggle Comment&lt;/a&gt;、&lt;a href="http://docs.emmet.io/actions/update-image-size/"&gt;Update Image Size&lt;/a&gt;、&lt;a href="http://docs.emmet.io/actions/select-item/"&gt;Select Item&lt;/a&gt;などのアクションがLESSとSCSS（SASSは除く）のファイルで動くようになります。&lt;/p&gt;

&lt;h3&gt;3. SlimとJadeの構文をサポート&lt;/h3&gt;

&lt;p&gt;Emmetの&lt;a href="http://docs.emmet.io/filters/"&gt;Filters&lt;/a&gt;の機能がアップデートされ、HTMLを&lt;a href="https://github.com/slim-template/slim"&gt;Slim&lt;/a&gt;および&lt;a href="https://github.com/visionmedia/jade"&gt;Jade&lt;/a&gt;の構文で展開できるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;p.title&amp;gt;a[/hoge/]|slim
↓
p.title
  a href=&amp;quot;/hoge/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4. CSS Gradientジェネレータのアップデート&lt;/h3&gt;

&lt;p&gt;W3C構文の仕様やCan I Useデータベースなど複数の定義をサポートします。&lt;/p&gt;

&lt;pre&gt;&lt;code class="css"&gt;lg(red, black)
↓
background-image: -webkit-linear-gradient(red, black);
background-image: -o-linear-gradient(red, black);
background-image: linear-gradient(red, black);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. Boolean型属性&lt;/h3&gt;

&lt;p&gt;属性名の後ろにドットを書くことで、同じ名前と値を持つ属性を短く書けるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;inp[type=radio][checked.]
↓
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;&amp;quot; id=&amp;quot;&amp;quot; checked&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6. 暗黙の属性値&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;img&lt;/code&gt;要素の&lt;code&gt;src&lt;/code&gt;属性などHTML要素において値が必須な属性は、その属性名を省略できるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;img[src=image.png]
↓
img[image.png]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;7. デフォルトの属性&lt;/h3&gt;

&lt;p&gt;属性が必須でない要素も暗黙の属性値によって値を展開できるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;script → &amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;
↓
script[jquery.js] → &amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;8. 新アクション「Update Tag」&lt;/h3&gt;

&lt;p&gt;新たに追加されるアクション「Update Tag」を使うことで、すでに記述（展開）済みのHTML要素をEmmetの機能で更新できるようになります。更新したい要素にカーソルを置き以下のコマンドを叩くと、「Enter Abbreviation:」というダイアログがエディタのウィンドウ下に開くので、追加したい属性や値を書いてEnterします。&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;header&amp;gt;|&amp;lt;/header&amp;gt;
↓
[shift]+[ctrl]+[u] → .global → Enter
↓
&amp;lt;header class=&amp;quot;global&amp;quot;&amp;gt;&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;9. アクション名「Match Tag Pair」を「Balance」に変更&lt;/h3&gt;

&lt;p&gt;v1でも実装されている&lt;a href="http://docs.emmet.io/actions/match-pair/"&gt;Match Tag Pair&lt;/a&gt;のアクション名が「Balance」に変更され、またCSSでもそのアクションが動くようになります。&lt;/p&gt;

&lt;h3&gt;10. CSSをシングルラインで展開できるオプションを追加&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;syntaxProfiles.json&lt;/code&gt;（Sublime Textなら&lt;code&gt;Emmet.sublime-settings&lt;/code&gt;）にて&lt;code&gt;&amp;quot;css&amp;quot;: &amp;quot;css_line&amp;quot;&lt;/code&gt;を設定するとCSSのプロパティがシングルラインで展開されるようになります。くわしくは&lt;a href="http://docs.emmet.io/customization/syntax-profiles/"&gt;こちらのドキュメント&lt;/a&gt;を参照。&lt;/p&gt;

&lt;h3&gt;11. RGBaカラーのシンタックスを追加&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;color&lt;/code&gt;プロパティなどでのカラーコードの展開において、後ろに&lt;code&gt;.N&lt;/code&gt;を付けることで、CSS3のRGBaで開きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class="css"&gt;c#dca.7
↓
color: rgba(221, 204, 170, 0.7);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;まとめ&lt;/h2&gt;

&lt;p&gt;公式ブログの該当エントリーには他にも、EmmetはそもそもNode.JSに準拠した書き方がされているので、npm packageとして提供される日も近いとのことです。実際、Emmetの開発版と思われるブランチが&lt;a href="https://github.com/emmetio/emmet/blob/umd/Gruntfile.js"&gt;Gruntでビルドできるように&lt;/a&gt;なっています。&lt;/p&gt;

&lt;p&gt;具体的なリリース日は未定ですが、その動向には注視していきたいです。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Gruntに置き換わるか？新生ビルドシステム「gulp」v3.5.2入門</title>
    <link rel="alternate" href="http://re-dzine.net/2014/02/getting-started-with-gulp/"/>
    <id>http://re-dzine.net/2014/02/getting-started-with-gulp/</id>
    <published>2014-02-07T02:56:00Z</published>
    <updated>2014-02-07T12:03:00+09:00</updated>
    <author>
      <name>konitter</name>
    </author>
    <content type="html">&lt;p&gt;みなさんご存知「&lt;a href="http://gruntjs.com/"&gt;Grunt&lt;/a&gt;」は、WEB制作者の間でも以前に比べるとだいぶ浸透してきているようで、実際に案件で使用しているという方も増えてきています。そんな中、ここ最近海外のエンジニアの中でGruntに変わって使われだしている新たなビルドシステム「&lt;a href="http://gulpjs.com/"&gt;gulp&lt;/a&gt;」をご紹介します。&lt;/p&gt;

&lt;h2&gt;Grunt vs gulp&lt;/h2&gt;

&lt;p&gt;Gruntは、設定ファイル&lt;code&gt;Gruntfile&lt;/code&gt;がJSON形式で書けるという側面から一見わかりやすく見えますが、実案件で使用する場合、10〜20個のプラグインを使うということもザラにあります。そうなると&lt;code&gt;Gruntfile&lt;/code&gt;の記述量がどんどん増えていき、どのタスクがどのタスクと繋がっていて、結果どうなるかが非常に分かりにくくなるという欠点があります。&lt;/p&gt;

&lt;p&gt;また、複数のタスクを使った一連の流れにおいて、個々のタスクを実行するたびにファイルの読み込みと書き込みが発生するため、非常に無駄の多い仕様になっています。このため、タスクおよびそのタスクの対象となるファイルが多くなると、タスクが完全に終了するまでに時間がかかってしまうということがあります。&lt;/p&gt;

&lt;p&gt;一方gulpは、ベースになっているNode.jsプログラムに基づいた書き方で設定ファイル&lt;code&gt;gulpfile&lt;/code&gt;が定義でき、どのファイルに対してどんな処理をするのかが一目瞭然となります（くわしくは後ほど）。プログラムライクで難しそうに見えますが、一度体験してみるとその良さに気付くことでしょう。&lt;/p&gt;

&lt;p&gt;さらに、個々のタスクは非同期に実行され、ファイルの扱いにおいても&lt;a href="http://nodejs.org/api/stream.html"&gt;Node.jsのStreamというAPI&lt;/a&gt;を使うことで中間ファイルを生成することなくやりとりできるので、非常に高速にタスクを実行することができます。Streamについてのくわしくはここでは割愛しますが、gulpの開発者たちも勧める「&lt;a href="https://github.com/substack/stream-handbook"&gt;substack/stream-handbook&lt;/a&gt;」を読むとより理解が深まるはずです。&lt;/p&gt;

&lt;h2&gt;Gruntfile vs gulpfile&lt;/h2&gt;

&lt;p&gt;では実際にGruntとgulpそれぞれの設定ファイルの違いを見てみます。ここでは、&lt;a href="https://github.com/twbs/bootstrap-sass"&gt;twbs/bootstrap-sass&lt;/a&gt;の40個あるSCSSファイルの監視 → CSSファイルへのコンパイル → autoprefixerによるベンダープレフィックスの付与、という一連の流れを例にしてみます。&lt;/p&gt;

&lt;h3&gt;Gruntfile.js&lt;/h3&gt;

&lt;pre&gt;&lt;code class="js"&gt;grunt.initConfig({
  sass: {
    dist: {
      files: [{
        cwd: &amp;#39;sass&amp;#39;,
        src: &amp;#39;bootstrap.scss&amp;#39;,
        dest: &amp;#39;.tmp/&amp;#39;,
        expand: true,
        ext: &amp;#39;.css&amp;#39;
      }]
    }
  },
  autoprefixer: {
    options: [&amp;#39;last 1 version&amp;#39;],
    dist: {
      files: [{
        expand: true,
        cwd: &amp;#39;.tmp/&amp;#39;,
        src: &amp;#39;bootstrap.css&amp;#39;,
        dest: &amp;#39;dist/css&amp;#39;
      }]
    }
  },
  watch: {
    styles: {
      files: [&amp;#39;sass/{,*/}*.scss&amp;#39;],
      tasks: [&amp;#39;sass:dist&amp;#39;, &amp;#39;autoprefixer:dist&amp;#39;]
    }
  }
});
grunt.registerTask(&amp;#39;default&amp;#39;, [&amp;#39;sass&amp;#39;, &amp;#39;watch&amp;#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gruntはプラグインごとに読み込み元のファイルと出力先のファイルを設定する必要があるため、非常に冗長です。これと同じ処理をgulpでやるとどうなるでしょうか？&lt;/p&gt;

&lt;h3&gt;gulpfile.js&lt;/h3&gt;

&lt;pre&gt;&lt;code class="js"&gt;gulp.task(&amp;#39;sass&amp;#39;, function () {
  gulp.src(&amp;#39;sass/bootstrap.scss&amp;#39;)
    .pipe(sass())
    .pipe(autoprefixer(&amp;#39;last 1 version&amp;#39;))
    .pipe(gulp.dest(&amp;#39;dist/css&amp;#39;));
});
gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;sass&amp;#39;], function() {
  gulp.watch(&amp;#39;sass/**/*.scss&amp;#39;, [&amp;#39;sass&amp;#39;]);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。特に2行目から5行目を見るとわかりますが、&lt;code&gt;gulp.src()&lt;/code&gt;で読み込んだファイルを&lt;code&gt;.pipe()&lt;/code&gt;を使って繋いだタスクで処理します。&lt;code&gt;sass()&lt;/code&gt;でコンパイルして&lt;code&gt;autoprefixer()&lt;/code&gt;でプレフィックス付けて、&lt;code&gt;gulp.dest()&lt;/code&gt;で出力。流れがわかりやすいですね。&lt;/p&gt;

&lt;p&gt;実際にこのGruntとgulpのタスクをMacbook Air（11-inch, Mid 2012）で実行したところ、以下のようになりました。&lt;/p&gt;

&lt;p&gt;&lt;img alt="Grunt" src="/img/2014/02/grunt.png" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt="gulp" src="/img/2014/02/gulp.png" /&gt;&lt;/p&gt;

&lt;p&gt;結果的にはgulpの方が若干早かったのですが、この実行時間にはGruntとgulp本体やそれぞれのプラグインの読み込み・起動時間が含まれているわけですし、プラグイン内部のプログラムおよび使っているモジュールも異なるので、単純に比較できるものではありません。同じ構成であってもプラグインの組み合わせやタスクの内容によってはGruntよりもgulpの方が時間がかかることもあるのです。&lt;/p&gt;

&lt;h2&gt;gulpを使ってみる&lt;/h2&gt;

&lt;p&gt;使い方はいたって簡単です。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;npm install -g gulp&lt;/code&gt;でgulpをグローバルにインストール。&lt;/li&gt;
&lt;li&gt;プロジェクトディレクトリに&lt;code&gt;package.json&lt;/code&gt;を用意。なければ&lt;code&gt;npm init&lt;/code&gt;で対話的に作成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install --save-dev gulp gulp-hoge&lt;/code&gt;でgulpとプラグインをローカルに入れる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gulpfile.js&lt;/code&gt;を作ってプロジェクトのルートに置く。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gulp [task name]&lt;/code&gt;で実行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;gulpのプラグインはnpmやGitHubで検索してもよいですし、プラグインのまとめページ&lt;a href="http://gratimax.github.io/search-gulp-plugins/"&gt;gulp plugins&lt;/a&gt;（記事の執筆時点では257個）から探すこともできます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gulpfile.js&lt;/code&gt;の書き方などについては、&lt;a href="https://github.com/gulpjs/gulp/blob/master/docs/README.md"&gt;gulpのドキュメントページ&lt;/a&gt;を一通り読んだうえで、あとは各プラグインのREADMEを参考にタスクを設定すれば期待通りに動くはずです。&lt;/p&gt;

&lt;h2&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ここまで言っといてなんですが結局のところ好みの問題なので、Gruntとgulpどっちがいいかを述べることは簡単ではありません。また、複数のエンジニアが案件に携わるような環境だと急にGruntからgulpに乗り換えるということが難しい場合もあると思います。&lt;/p&gt;

&lt;p&gt;また、実行速度の違いに関しては、GitHubで公開されている&lt;a href="https://github.com/gruntjs/grunt-docs/blob/master/Roadmap.md"&gt;Gruntの次期バージョンv0.5のロードマップ&lt;/a&gt;を見ると、それこそgulpのように複数のタスクをつなげてデータのやり取りができるようになるみたいですので、将来的には変わらなくなるのかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// load a set of tasks to be run in parallel
grunt.registerTask(&amp;#39;name&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;concat&amp;#39;], { parallel:true });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とにかく大事なのは、なんのためにビルドツールを使うのかということです。そこを忘れずにいれば、Gruntもgulpもどちらも便利なツールであることには違いありませんので、クオリティーの高い制作を行うことができるでしょう。&lt;/p&gt;
</content>
  </entry>
</feed>
